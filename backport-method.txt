This document details the method to use the package android.net.rtp in versions before Honeycomb, where it was first introduced.

Usage of the API
------------------------
There are 4 Java files in the package android.net.rtp. These are RtpStream.java, AudioStream.java (derived from RtpStream), AudioGroup.java and AudioCodec.java. 
An AudioStream represents a remote endpoint which consists of a network mapping and a configured AudioCodec. On the other side, An AudioGroup represents a local endpoint which mixes all the AudioStreams and optionally interacts with the speaker and the microphone at the same time. The simplest usage includes one for each endpoints. An AudioGroup is an audio hub for the speaker, the microphone, and AudioStreams. Each of these components can be logically turned on or off by calling setMode(int) or setMode(int). The AudioGroup will go through these components and process them one by one within its execution loop. The loop consists of four steps. 
1) For each AudioStream not in MODE_SEND_ONLY, decodes its incoming packets and stores in its buffer. 
2) If the microphone is enabled, processes the recorded audio and stores in its buffer. 
3) if the speaker is enabled, mixes all AudioStream buffers and plays back. 
4) For each AudioStream not in MODE_RECEIVE_ONLY, mixes all other buffers and sends back the encoded packets. 
An AudioGroup does nothing if there is no AudioStream in it.

In order to create a stream of audio between two users, these are the steps:

audioStream = new AudioStream(localInetAddress); // initializes an audioStream on a given local IP Address, on a random port around 50000.
localAudioPort = audioStream.getLocalPort(); // gets the port on which it has been initialized. This info must be sent to the remote peer.

AudioCodec localAudioCodec = AudioCodec.AMR; // chooses the Audio codec for the transmission. A number of options are available.
audioGroup = new AudioGroup(); // initializes an audioGroup that is empty. An AudioGroup is a collection of AudioStreams.
audioGroup.setMode(AudioGroup.MODE_NORMAL); // sets the mode on which the AudioGroup must operate. Detailed explanation given later.

audioStream.associate(remoteInetAddress, remoteAudioPort); // The AudioStream is associated with the remote peer.
audioStream.setCodec(localAudioCodec); // The codec which the AudioStream uses is set.
audioStream.join(audioGroup); // The AudioStream joins the AudioGroup.

For further documentation: http://developer.android.com/reference/android/net/rtp/package-summary.html

Backport of the API
------------------------
The Backport was accomplished by compiling the native code that the java files depend upon. These can be found in the Android source code under /frameworks/base/voip/ . As can be found in the Android.mk file (that gives instructions on how it should be built), the files required in order for it to work are the .cpp files in that folder, as well as certain shared and static libraries.
Though there are only 5 shared libraries and 3 static libraries, it is not possible to build each of these manually as they depend on other libraries. The only solution is to build the entire Android source, which will resolve dependencies automatically and generate the library that is required.
Instructions on how to build the android source can be found here:
http://source.android.com/source/initializing.html
http://mjanja.co.ke/2011/11/building-android-4-0-on-ubuntu-11-10/
All files generated by the compilation will be found in the newly created out/ directory. Every shared library has two files associated with it, one large and one small. I was not able to find the relationship between the two files, except that I noted even building the native source in any app generates 2 .so files, one in the libs/ directory and the other in the obj/ directory. 
The voip features appear to work even if only one of the two libjni_rtp.so files is included, and it is not certain why this is. Perhaps the larger .so contains the statically linked code.
If required, it should also be possible to get the 5 shared libraries and the 3 static libraries from the out/ directory and then use build them to build the native code to obtain the required library files, but some errors were encountered while attempting that, that proved difficult to resolve.       



